# Censor sensitive information in logs
# This censors any Jellyfin api_key URL parameter from the logfile.
log_format stripjellyfinsecrets '$remote_addr $host - $remote_user [$time_local] '
                                '"$jellyfinsecretfilter" $status $body_bytes_sent '
                                '$request_length $request_time $upstream_response_time '
                                '"$http_referer" "$http_user_agent"';

map $request $jellyfinsecretfilter {
    ~*^(?<prefix1>.*[\?&]api_key=)([^&]*)(?<suffix1>.*)$  "${prefix1}***$suffix1";
    default                                               $request;
}


# Cache Video streams & poster images
# ref: https://jellyfin.org/docs/general/networking/nginx.html#cache-video-streams
# NOTE: min_free is not supported until 1.19, I started with 1.18
proxy_cache_path  /var/cache/nginx levels=1:2 keys_zone=jellyfin:32m max_size=12g use_temp_path=off;
map $request_uri $h264Level { ~(h264-level=)(.+?)& $2; }
map $request_uri $h264Profile { ~(h264-profile=)(.+?)& $2; }

server {
    listen 80;
    listen [::]:80;

    # Uncomment to redirect HTTP to HTTPS
    # return 301 https://$host$request_uri;

    # listen 443 ssl http2;
    # listen [::]:443 ssl http2;
    server_name _;  # All server names, I think

    # ref: https://jellyfin.org/docs/general/networking/nginx.html#censor-sensitive-information-in-logs
    access_log /var/log/nginx/access.log stripjellyfinsecrets;

    # NOTE: This is *just* a caching proxy, all security headers should've been implemented at the other end anyway

    # Get the variable with the upstream server URL
    include snippets/dns_hack.conf;

#     # proxy_set_header Host $host;
#     # proxy_set_header X-Real-IP $remote_addr;
#     # proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
#     # proxy_set_header X-Forwarded-Proto $scheme;
#     # proxy_set_header X-Forwarded-Protocol $scheme;
#     # proxy_set_header X-Forwarded-Host $http_host;

    # FIXME: Consider using proxy_store instead of cache for some things
    add_header Cache-Control "shared";
    add_header X-Cache-Status $upstream_cache_status; # This is only to check if cache is working

    proxy_cache_valid 200 206 301 302 30d;

    proxy_cache_use_stale error timeout invalid_header updating http_500 http_502 http_503 http_504;
    proxy_cache_background_update on;
    proxy_cache_lock on;

    # Ignore the client telling us not to cache it.
    # FIXME: This is kinda naughty, is it actually necessary?
    proxy_ignore_headers Expires Cache-Control Set-Cookie X-Accel-Expires;

# Recommended by the Jellyfin wiki, but it seems to break all caching
#    # Disable buffering when the nginx proxy gets very resource heavy upon streaming
#    proxy_buffering off;

    # Poster images and such
    location ~ /Items/(.*)/Images {
        proxy_pass $jellyfin_base_url;

        proxy_cache jellyfin;
        proxy_cache_key "$jellyfin_base_url $request_uri $args";
        proxy_cache_revalidate on;
    }

    # The video streams themselves
    # Needs "slice" otherwise the proxy will cache the entire file before even starting to give it to the client properly
    location /Videos/ {
        proxy_pass $jellyfin_base_url;

        proxy_cache jellyfin;
        proxy_cache_key "$jellyfin_base_url $request_uri $args $h264Profile $h264Level $slice_range";
#        proxy_cache_key "$host$request_uri?MediaSourceId=$arg_MediaSourceId&VideoCodec=$arg_VideoCodec&AudioCodec=$arg_AudioCodec&AudioStreamIndex=$arg_AudioStreamIndex&VideoBitrate=$arg_VideoBitrate&AudioBitrate=$arg_AudioBitrate&SubtitleMethod=$arg_SubtitleMethod&TranscodingMaxAudioChannels=$arg_TranscodingMaxAudioChannels&RequireAvc=$arg_RequireAvc&SegmentContainer=$arg_SegmentContainer&MinSegments=$arg_MinSegments&BreakOnNonKeyFrames=$arg_BreakOnNonKeyFrames&h264-profile=$h264Profile&h264-level=$h264Level";

        # Allow caching files in ranged slices
        # Needed so that we can cache & send only the parts of a video being requested rather than downloading the entire thing before sending any of the later parts.
        # NOTE: This "$slice_range" *must* be included in the proxy_cache_key when using slice, otherwise it breaks the entire download after the first slice
        slice 4m;  # FIXME: Tune this
        proxy_set_header  Range $slice_range;
        # HTTP 1.0 does not support range requests, so upgrade it to 1.1
        proxy_http_version 1.1;
    }

    # Main Jellyfin traffic
    location / {
        proxy_pass $jellyfin_base_url;
        # Mostly API calls and other variable data, don't cache
    }

    # Jellyfin's API endpoint for querying the server info
    # I need to do this special to stop the backend server from telling the client how to connect directly,
    # because that causes the client to completely bypass this caching proxy.
    location /System/Info/Public {
        proxy_pass $jellyfin_base_url/System/Info/Public;
        # FIXME: Consider just returning a string:
        # add_header Content-Type application/json
        # return 200 '{"LocalAddress":"http://$HOSTNAME","ServerName":"Abrahall Media","ProductName":"Jellyfin Server","OperatingSystem":"Linux","Id":"74133c9e43bb41759da6ea5c900ac3f9"}'
        proxy_set_header Accept-Encoding "";
        subs_filter_types application/json;
        # All the Jellyfin clients I've dealt with so far have their own internal logic for how to deal with a nonexistant LocalAddress,
        # so I'm just going to let them deal with that properly rather than trying to rewrite the LocalAddress myself.
        subs_filter "LocalAddress" "Don'tUseThis";
    }

    # Jellyfin Websockets traffic
    location /socket {
        proxy_pass $jellyfin_base_url;

        # Upgrade the request to a websocket
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
    }

    # Not actually Jellyfin
    # This is my PXE boot server.
    location /netboot/ {
        proxy_pass $netboot_base_url;

        # FIXME: Consider using "slice" here.
        #        Not currently necessary because I use fetch= to download it all at once, but might still help.

        # FIXME: Use a separate cache for the netboot data?
        proxy_cache jellyfin;
        proxy_cache_key "$netboot_base_url $request_uri $args";
        proxy_cache_revalidate on;
    }

}
